<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://www.briglamoreaux.com/tag/json/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://www.briglamoreaux.com/" rel="alternate" type="text/html" />
  <updated>2023-06-22T22:10:01+00:00</updated>
  <id>https://www.briglamoreaux.com/tag/json/feed.xml</id>

  
  
  

  
    <title type="html">Brig Lamoreaux | </title>
  

  
    <subtitle>Long term storage for a forgetful mind</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Json Serialization</title>
      <link href="https://www.briglamoreaux.com/2009/02/04/json-serialization.html" rel="alternate" type="text/html" title="Json Serialization" />
      <published>2009-02-04T00:00:00+00:00</published>
      <updated>2009-02-04T00:00:00+00:00</updated>
      <id>https://www.briglamoreaux.com/2009/02/04/json-serialization</id>
      <content type="html" xml:base="https://www.briglamoreaux.com/2009/02/04/json-serialization.html">&lt;p&gt;I’ve been having fun trying to implement an idea I have. Part of the idea involves caching objects to &lt;a href=&quot;http://www.danga.com/memcached/&quot;&gt;memcached&lt;/a&gt; in &lt;a href=&quot;http://json.org/&quot;&gt;Json&lt;/a&gt; format. The idea being that the object saved to memcached wouldn’t be bound to .Net specific methodology.&lt;/p&gt;

&lt;h2 id=&quot;whats-out-there&quot;&gt;What’s out There&lt;/h2&gt;

&lt;p&gt;At first I looked into creating a &lt;a href=&quot;http://msdn.microsoft.com/en-us/magazine/cc188950.aspx&quot;&gt;Custom Formatter&lt;/a&gt; that would serialize my object for me. That seemed like an overkill so I searched for a faster and prepackaged library. After poking around to see what Json serializers were on the market, I found &lt;a href=&quot;http://www.codeplex.com/Json&quot;&gt;Json.NET&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At first this looked like a possible solution. Then I ran the Test Scripts on the Project and found a PerformanceTests test. This test script had timings for three different types of serializers. So my options were:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Roll my own with a &lt;a href=&quot;http://msdn.microsoft.com/en-us/magazine/cc188950.aspx&quot;&gt;Custom formatter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.codeplex.com/Json&quot;&gt;Json.NET&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.web.script.serialization.javascriptserializer.aspx&quot;&gt;JavaScriptSerializer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.runtime.serialization.json.datacontractjsonserializer.aspx&quot;&gt;DataContractJsonSerializer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;I changed the Json.Net Performance tests to serialize and deserialize 1000 times. The JavaScriptSerializer was the fastest during the tests.&lt;/p&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;400&quot; border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;200&quot;&gt;&lt;strong&gt;Serializer&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; width=&quot;200&quot;&gt;&lt;strong&gt;Time&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;200&quot;&gt;JsonNet&lt;/td&gt;&lt;td valign=&quot;top&quot; width=&quot;200&quot;&gt;203 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;200&quot;&gt;JavaScriptSerializer&lt;/td&gt;&lt;td valign=&quot;top&quot; width=&quot;200&quot;&gt;95 ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;200&quot;&gt;DataContractJsonSerializer&lt;/td&gt;&lt;td valign=&quot;top&quot; width=&quot;200&quot;&gt;842 ms&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h2 id=&quot;strangeness&quot;&gt;Strangeness&lt;/h2&gt;

&lt;p&gt;One of the bad things I saw happen is how the DataContractJsonSerializer tried to serialize the private methods of the class. So I though I would try to force it to use the properties of the class by not defining a backing variable.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public string Name { get; set; }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;What to my surprise when I saw the following in the Json output:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;&amp;lt;Name&amp;gt;k__BackingField&quot;:&quot;Rick&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Weird.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Brig Lamoreaux</name>
        
        
      </author>

      

      
        <category term="net" />
      
        <category term="json" />
      

      
        <summary type="html">I’ve been having fun trying to implement an idea I have. Part of the idea involves caching objects to memcached in Json format. The idea being that the object saved to memcached wouldn’t be bound to .Net specific methodology.</summary>
      

      
      
    </entry>
  
</feed>
